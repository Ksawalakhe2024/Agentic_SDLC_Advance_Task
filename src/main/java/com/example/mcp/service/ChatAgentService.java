package com.example.mcp.service;

import com.example.mcp.dto.TaskDto;
import com.example.mcp.entity.Task;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Service
public class ChatAgentService {

    private final McpService mcpService;

    public ChatAgentService(McpService mcpService) {
        this.mcpService = mcpService;
    }

    public static class AgentResult {
        public String reply;
        public Map<String, Object> data;

        public AgentResult(String reply, Map<String, Object> data) {
            this.reply = reply;
            this.data = data;
        }
    }

    public AgentResult handle(String userMessage) {
        if (userMessage == null || userMessage.isBlank()) {
            return new AgentResult("Please type a message describing what you want to do.", Map.of());
        }

        String msg = userMessage.trim().toLowerCase(Locale.ROOT);

        // 1) Schema request
        if (msg.contains("schema")) {
            Map<String, Object> schema = mcpService.getTaskSchema();
            return new AgentResult(
                    "Here is the tasks schema. I can now generate data or show a summary.",
                    Map.of("schema", schema)
            );
        }

        // 2) Generate and insert N tasks (defaults to 1000 if not specified)
        if (msg.contains("generate") || msg.contains("insert")) {
            int n = extractCount(msg, 1000);
            List<TaskDto> tasks = generateTasks(n);
            Map<String, Object> insertResult = mcpService.insertTasks(tasks);
            Map<String, Object> summary = mcpService.getSummary();

            return new AgentResult(
                    "I generated and inserted " + insertResult.get("inserted") + " tasks. Here's the updated summary.",
                    Map.of("insertResult", insertResult, "summary", summary)
            );
        }

        // 3) Summary
        if (msg.contains("summary") || msg.contains("count")) {
            Map<String, Object> summary = mcpService.getSummary();
            return new AgentResult(
                    "Here is the current summary of tasks.",
                    Map.of("summary", summary)
            );
        }

        // Help
        return new AgentResult(
                "I can: (1) show schema, (2) generate and insert tasks (e.g., 'generate 1000 tasks'), (3) show summary.",
                Map.of("help", List.of(
                        "Type: show schema",
                        "Type: generate 1000 tasks",
                        "Type: show summary"
                ))
        );
    }

    private int extractCount(String msg, int fallback) {
        // Try to find a number in the message, else fallback
        try {
            var m = java.util.regex.Pattern.compile("(\\d{2,5})").matcher(msg);
            if (m.find()) return Integer.parseInt(m.group(1));
        } catch (Exception ignored) {}
        if (msg.contains("thousand")) return 1000;
        return fallback;
    }

    private List<TaskDto> generateTasks(int n) {
        String[] statuses = {"TODO", "IN_PROGRESS", "DONE", "BLOCKED"};
        String[] priorities = {"LOW", "MEDIUM", "HIGH"};
        String[] people = {"Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Heidi", "Ivan", "Judy"};
        ThreadLocalRandom r = ThreadLocalRandom.current();

        return IntStream.range(0, n).mapToObj(i -> {
            TaskDto t = new TaskDto();
            t.setTitle(randomTitle(i));
            t.setDescription("Auto-generated by agent. Seed=" + i);
            t.setStatus(statuses[r.nextInt(statuses.length)]);
            t.setPriority(priorities[r.nextInt(priorities.length)]);
            t.setAssignee(people[r.nextInt(people.length)]);
            t.setDueDate(LocalDate.now().plusDays(r.nextInt(1, 60)).toString());
            return t;
        }).collect(Collectors.toList());
    }

    private String randomTitle(int i) {
        String[] verbs = { "Refactor", "Implement", "Fix", "Review", "Draft", "Design", "Test", "Document" };
        String[] nouns = { "API", "Endpoint", "Workflow", "UI", "Schema", "Module", "Service", "Test Case" };
        ThreadLocalRandom r = ThreadLocalRandom.current();
        return verbs[r.nextInt(verbs.length)] + " " + nouns[r.nextInt(nouns.length)] + " #" + i;
    }
}